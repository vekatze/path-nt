import {
  core.c-int {c-int, from-c-int},
  core.c-size {c-size},
  core.c-string {c-string, from-c-string, to-c-string},
  core.control {discard},
  core.list {filter, for, for-each},
  core.magic,
  core.memory {load-int, store-int8},
  core.pointer {null-pointer, shift},
  core.system {get-error-message, report-system-error, system},
  core.text {text-byte-length},
  core.text.io {print-line},
  this.entity.dirent {Dirent, dirent},
  this.entity.dirent.show {show-dirent},
  this.entity.dtype {dtype-from-int},
  this.path {drop-last},
  time.time {Time, time, to-ISO8601-local},
}

foreign {
  getcwd(pointer, c-size): pointer,
  opendir(pointer): pointer,
  readdir(pointer): pointer,
  closedir(pointer): c-int,
  neut_path_v0_1_GET_DNAME(pointer): pointer,
  neut_path_v0_1_GET_DTYPE(pointer): int8,
  neut_path_v0_1_mkdir(pointer, int): int,
  neut_path_v0_1_get_modification_time(pointer, pointer, pointer): int,
}

data _directory {}

define get-current-directory(): system(text) {
  let result = magic external getcwd(null-pointer, 0);
  if eq-int(magic cast(pointer, int, result), 0) {
    report-system-error()
  } else {
    pin cwd = core.magic.cast(pointer, c-string, result);
    Right(from-c-string(cwd))
  }
}

define _open-directory(p: &text): system(_directory) {
  let c-str = to-c-string(p);
  let result on c-str = magic external opendir(magic cast(&c-string, pointer, c-str));
  discard(c-str);
  if eq-int(magic cast(pointer, int, result), 0) {
    report-system-error()
  } else {
    Right(core.magic.cast(pointer, _directory, result))
  }
}

define _read-directory(d: _directory): list(dirent) {
  let result = magic external readdir(magic cast(_directory, pointer, d));
  if eq-int(magic cast(pointer, int, result), 0) {
    Nil
  } else {
    let name = from-c-string(magic cast(pointer, &c-string, magic external neut_path_v0_1_GET_DNAME(result)));
    let kind = dtype-from-int(magic external neut_path_v0_1_GET_DTYPE(result));
    Cons(Dirent of {kind, name}, _read-directory(d))
  }
}

define _close-directory(d: _directory): system(unit) {
  let result = magic external closedir(magic cast(_directory, pointer, d));
  if eq-int(from-c-int(result), -1) {
    report-system-error()
  } else {
    Right(Unit)
  }
}

define read-directory(p: &text): system(list(dirent)) {
  try dir = _open-directory(p);
  let output = _read-directory(dir);
  try _ = _close-directory(dir);
  Right(output)
}

define get-directory-contents(dir-path: &text): system(list(text)) {
  try items = read-directory(dir-path);
  let items =
    filter(items, function (i) {
      tie Dirent of {name} = i;
      and(ne-text(name, "."), ne-text(name, ".."))
    });
  Right(for-each(items, function (i) {
    let Dirent of {name} = i;
    pin name = name;
    this.path.append(dir-path, name)
  }))
}

foreign {
  neut_path_v0_1_is_regular_file(pointer): int,
  neut_path_v0_1_is_directory(pointer): int,
  llvm.memcpy.p0.p0.i64(pointer, pointer, int64, int1): void,
}

define _to-c-string-buf(t: &text, len: int, buf: pointer): unit {
  let src-ptr = core.text._get-content-pointer(t);
  let _ = magic external llvm.memcpy.p0.p0.i64(buf, src-ptr, len, 0);
  store-int8(0, shift(buf, len));
}

inline is-regular-file(t: &text): bool {
  let len = text-byte-length(t);
  let buf = magic alloca(int8, add-int(len, 1));
  _to-c-string-buf(t, len, buf);
  eq-int(magic external neut_path_v0_1_is_regular_file(buf), 1)
}

inline is-directory(t: &text): bool {
  let len = text-byte-length(t);
  let buf = magic alloca(int8, add-int(len, 1));
  _to-c-string-buf(t, len, buf);
  eq-int(magic external neut_path_v0_1_is_directory(buf), 1)
}

define create-directory<mode := 0o777>(t: &text): system(unit) {
  let len = text-byte-length(t);
  let buf = magic alloca(int8, add-int(len, 1));
  _to-c-string-buf(t, len, buf);
  let result = magic external neut_path_v0_1_mkdir(buf, mode);
  if lt-int(result, 0) {
    report-system-error()
  } else {
    Right(Unit)
  }
}

define get-modification-time<r := rho>(path: &text): system(time) {
  let len = text-byte-length(path);
  let buf = magic alloca(int8, add-int(len, 1));
  _to-c-string-buf(path, len, buf);
  let sec = magic alloca(int, 1);
  let nsec = magic alloca(int, 1);
  let result = magic external neut_path_v0_1_get_modification_time(buf, sec, nsec);
  if lt-int(result, 0) {
    try _ = r;
    report-system-error()
  } else {
    let sec = load-int(sec);
    let nsec = load-int(nsec);
    try _ = r;
    Right(Time of {seconds := sec, nanoseconds := nsec})
  }
}

define test-zen(): system(unit) {
  try out = read-directory("/Users/");
  for(out, function (item) {
    pin t = show-dirent(item);
    print-line(t);
  });
  try cwd = get-current-directory();
  pin cwd = cwd;
  pin p2 = drop-last(cwd);
  print("→");
  print(p2);
  print-line("←");
  Right(Unit)
}

define zen(): unit {
  match get-modification-time("/Users/vekatze/Desktop/out.js") {
  | Left(_) =>
    Unit
  | Right(t) =>
    pin t = to-ISO8601-local(t, 8);
    vet(t);
  };
  pin b = is-regular-file("/usr/bin/xxd");
  vet(b);
  pin b = is-regular-file("/usr/bin/");
  vet(b);
  pin b = is-directory("/etc");
  vet(b);
  pin b = is-directory("/etc/");
  vet(b);
  match test-zen() {
  | Left(e) =>
    pin e = get-error-message(e);
    print-line(e);
  | Right(_) =>
    print("ok\n")
  }
}
